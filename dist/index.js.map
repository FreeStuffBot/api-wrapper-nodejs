{
  "version": 3,
  "sources": ["../src/rest.ts", "../src/bitfield.ts", "../src/events.ts", "../src/verifier.ts", "../src/webhooks.ts", "../src/parser.ts"],
  "sourcesContent": [
    "import { getCompatibility, getUa } from './const' with { type: 'macro' };\n\nimport axios from 'axios';\nimport { FsbStaticApiV2EventList, FsbStaticApiV2ProblemList, FsbStaticApiV2Schema, FsbStaticApiV2SchemaList } from './types';\n\n\ntype Options = {\n  baseUrl?: string,\n};\n\nconst defaultOptions: Options = {\n  baseUrl: 'https://api.freestuffbot.xyz/v2', \n};\n\nexport class RestApiClient {\n\n  private baseUrl: string;\n  private headers: Record<string, string> = {}\n\n  constructor(\n    readonly token: string,\n    readonly options: Options,\n  ) {\n    this.baseUrl = options.baseUrl || defaultOptions.baseUrl;\n    this.headers['Authorization'] = `Bearer ${token}`;\n    this.headers['User-Agent'] = getUa();\n    this.headers['Content-Type'] = 'application/json';\n    this.headers['X-Set-Compatibility-Date'] = getCompatibility();\n  }\n\n  public getPing() {\n    return axios({\n      method: 'GET',\n      headers: this.headers,\n      baseURL: this.baseUrl,\n      url: '/ping',\n    })\n  }\n\n  public readonly static = {\n    getSchemas() {\n      return axios.get<FsbStaticApiV2SchemaList>('/schemas', {\n        headers: this.headers,\n        baseURL: this.baseUrl,\n      })\n    },\n    getSchema(urn: string) {\n      return axios.get<FsbStaticApiV2Schema>(`/schemas/${urn}`, {\n        headers: this.headers,\n        baseURL: this.baseUrl,\n      })\n    },\n    getProblems() {\n      return axios.get<FsbStaticApiV2ProblemList>('/problems', {\n        headers: this.headers,\n        baseURL: this.baseUrl,\n      })\n    },\n    getEvents() {\n      return axios.get<FsbStaticApiV2EventList>('/events', {\n        headers: this.headers,\n        baseURL: this.baseUrl,\n      })\n    },\n  }\n\n}\n",
    "\n\nexport type Bitfield<Items extends string> = {\n  has: (item: Items) => boolean;\n  add: (item: Items) => void;\n  remove: (item: Items) => void;\n  toggle: (item: Items) => void;\n  getBits: () => number;\n  toString: () => string;\n  toArray: () => Items[];\n  size: () => number;\n  [Symbol.iterator]: () => IterableIterator<Items>;\n}\n\nexport function createBitfield<Items extends string>(from: number, model: Record<Items, number>): Bitfield<Items> {\n  let local = from;\n\n  const iterate = function* () {\n    for (const item of Object.keys(model) as Items[]) {\n      if (local & model[item]) {\n        yield item;\n      }\n    }\n  };\n\n  return {\n    has: (item) => (local & model[item]) !== 0,\n    add: (item) => void (local |= model[item]),\n    remove: (item) => void (local &= ~model[item]),\n    toggle: (item) => void (local ^= model[item]),\n    getBits: () => local,\n    toString : () => [ ...iterate() ].join(', '),\n    toArray : () => [ ...iterate() ],\n    size: () => [ ...iterate() ].length,\n    [Symbol.iterator]: () => iterate(),\n  };\n}\n",
    "import { EventEmitter } from 'node:events';\nimport { FsbEvent } from './types';\n\n\ntype EventType = FsbEvent['type'];\n\nexport type Listener<T extends EventType> = (event: FsbEvent & { type: T }) => any;\n\nconst emitter = new EventEmitter();\n\nexport function on<T extends EventType>(event: T, listener: Listener<T>) {\n  emitter.on(event, listener);\n}\n\nexport function once<T extends EventType>(event: T, listener: Listener<T>) {\n  emitter.once(event, listener);\n}\n\nexport function off<T extends EventType>(event: T, listener: Listener<T>) {\n  emitter.off(event, listener);\n}\n\nexport function emit(event: FsbEvent) {\n  emitter.emit(event.type, event);\n}\n",
    "import { createPublicKey, verify, type KeyObject } from 'node:crypto';\n\n\nexport type VerifierOptions = {\n  /** the public key to verify the message payload against */\n  publicKey: string | KeyObject\n  /** controls the timestamp check and for how long messageIds are stored */\n  maxMessageAge?: number\n  /** skip storing and comparing messageIds for replay attacks, not recommended */\n  skipDuplicateCheck?: boolean\n  /** skip checking the timestamp for dates in the past, not recommended */\n  skipTimestampCheck?: boolean\n};\n\nexport type VerificationInput = {\n  /** the raw message body as a buffer (http body, **not parsed**) */\n  data: Buffer,\n  /** the payload signature (webhook-signature header) */\n  signature: string,\n  /** the message id (webhook-id header) */\n  messageId: string,\n  /** the string timestamp of this message's delivery (webhook-timestamp header) */\n  timestamp: string,\n};\n\nexport type VerificationStatus\n  /** the input was verified and is valid */\n  = 'valid'\n  /** some of the input parameters are missing */\n  | 'missing-parameters'\n  /** the signature was not matching the input */\n  | 'invalid-signature'\n  /** the timestamp was invalid, e.g. too old */\n  | 'invalid-timestamp'\n  /** the signature was created using an unsupported algorithm */\n  | 'unsupported-algorithm'\n  /** this message has already been received before */\n  | 'duplicate';\n\nexport type VerificationOutput = {\n  success: true\n  status: 'valid'\n  payloadJson: Record<string, unknown> | null\n  payloadRaw: Buffer\n} | {\n  success: false\n  status: Omit<VerificationStatus, 'valid'>\n  payloadJson: null\n  payloadRaw: null\n};\n\nexport type SignedMessageVerifier = (input: VerificationInput) => VerificationOutput;\n\nexport function newSignedMessageVerifier(options: VerifierOptions) {\n  const key = (typeof options.publicKey === 'string')\n    ? createPublicKey({\n      key: Buffer.from(options.publicKey, 'base64'),\n      format: 'der',\n      type: 'spki',\n    })\n    : options.publicKey;\n\n  const maxMessageAge = options.maxMessageAge ?? 5 * 60 * 1000; // default to 5 minutes\n  const skipDuplicateCheck = options.skipDuplicateCheck ?? false;\n  const skipTimestampCheck = options.skipTimestampCheck ?? false;\n\n  const storedMessageIds: Set<string> = new Set();\n  const deleteMessageIdsAfter = maxMessageAge + 1 * 60 * 1000; // keep for 1 minute longer to be sure\n\n  const isDateOlderThanMaxAge = (date: Date): boolean => {\n    const now = new Date();\n    return (now.getTime() - date.getTime()) > maxMessageAge;\n  };\n\n  return (input: VerificationInput): VerificationOutput => {\n    if (!input.data || !input.signature || !input.messageId || !input.timestamp) {\n      return {\n        success: false,\n        status: 'missing-parameters',\n        payloadJson: null,\n        payloadRaw: null,\n      };\n    }\n\n    const asDate = new Date(input.timestamp);\n    if (!skipTimestampCheck && (isNaN(asDate.getTime()) || isDateOlderThanMaxAge(asDate))) {\n      return {\n        success: false,\n        status: 'invalid-timestamp',\n        payloadJson: null,\n        payloadRaw: null,\n      };\n    }\n\n    if (!skipDuplicateCheck && storedMessageIds.has(input.messageId)) {\n      return {\n        success: false,\n        status: 'duplicate',\n        payloadJson: null,\n        payloadRaw: null,\n      };\n    }\n\n    if (skipDuplicateCheck) {\n      storedMessageIds.add(input.messageId);\n      setTimeout(() => {\n        storedMessageIds.delete(input.messageId);\n      }, deleteMessageIdsAfter);\n    }\n\n    const [version, sigB64] = String(input.signature).split(',');\n    if (version !== 'v1a') {\n      return {\n        success: false,\n        status: 'unsupported-algorithm',\n        payloadJson: null,\n        payloadRaw: null,\n      };\n    }\n\n    const sigBuff = Buffer.from(sigB64!, 'base64');\n    const contentBuff = Buffer.from(`$Sinput.messageId}.${input.timestamp}.${input.data.toString()}`, 'utf8');\n\n    const valid = verify(null, new Uint8Array(contentBuff), key, sigBuff);\n    if (!valid) {\n      return {\n        success: false,\n        status: 'invalid-signature',\n        payloadJson: null,\n        payloadRaw: null,\n      };\n    }\n\n    return {\n      success: true,\n      status: 'valid',\n      payloadJson: input.data.toString()\n        ? JSON.parse(input.data.toString())\n        : null,\n      payloadRaw: input.data,\n    }\n  };\n}\n",
    "import { getCompatibility, getUa } from './const' with { type: 'macro' };\n\nimport type { Request, Response, NextFunction } from 'express';\nimport type { KeyObject } from 'node:crypto';\nimport express, { raw } from 'express';\nimport { newSignedMessageVerifier, type VerifierOptions } from './verifier';\nimport { emit } from './events';\nimport { parseEvent } from './parser';\n\n\n/** Add freestuff webhooks to any existing express app */\nexport function createExpressHandler(pubkey: string | KeyObject, options?: Partial<Omit<VerifierOptions, 'publicKey'>>) {\n  const verifier = newSignedMessageVerifier({\n    publicKey: pubkey,\n    ...(options ?? {}),\n  });\n\n  const rawParser = raw({ type: '*/*' });\n\n  return (req: Request, res: Response, next: NextFunction) => {\n    rawParser(req, res, (err) => {\n      res.setHeader('X-Set-Compatibility-Date', getCompatibility());\n      res.setHeader('X-Client-Library', getUa());\n      \n      if (err) {\n        return void res.status(500).send('Error parsing request body');\n      }\n\n      if (!req.body) {\n        return void res.status(400).send('Missing body');\n      }\n\n      if (!Buffer.isBuffer(req.body)) {\n        console.warn('Webhook body is not a Buffer! Please move any mentions of `use(express.json())` after the webhook handler.');\n        return void res.status(500).send('Invalid server configuration');\n      }\n\n      const result = verifier({\n        data: req.body,\n        signature: String(req.headers['webhook-id']),\n        messageId: String(req.headers['webhook-signature']),\n        timestamp: String(req.headers['webhook-timestamp']),\n      });\n\n      if (!result.success) {\n        return void res.status(400).send(`Verification failed: ${result.status}`);\n      }\n\n      const compatibilityDate = req.headers['x-compatibility-date'];\n      if (compatibilityDate !== getCompatibility()) {\n        return void res.status(400).send('Incompatible compatibility date');\n      }\n\n      res.status(204).end();\n\n      if (!result.payloadJson.type || !String(result.payloadJson.type).startsWith('fsb:event:')) {\n        console.warn(`Received a correctly signed but unsupported payload.`);\n        console.log(result.payloadJson);\n        return;\n      }\n\n      emit(parseEvent(result.payloadJson))\n    });\n  };\n}\n\n/** Let us create an express server for you and already register everything you need. */\nexport function createExpressServer(options: VerifierOptions & { port?: number, route?: string }) {\n  const handler = createExpressHandler(options.publicKey, options);\n  const app = express();\n  if (options.route) {\n    app.use(options.route, handler);\n  } else {\n    app.use(handler);\n  }\n  const { promise, resolve } = Promise.withResolvers<{ app: typeof app, port: number }>();\n  const port = options.port ?? 3000;\n  app.listen(port, () => resolve({ app, port }));\n  return promise;\n}\n",
    "import { createBitfield } from './bitfield'\nimport type { FsbEvent, Product, ResolvedAnnouncement } from './types';\n\n\nconst productFlags = {\n  TRASH: 1<<0,\n  THIRDPARTY: 1<<1,\n  PERMANENT: 1<<2,\n  STAFF_PICK: 1<<3,\n  FIRSTPARTY_EXCLUSIVE: 1<<4,\n};\n\nconst productUrlFlags = {\n  ORIGINAL: 1<<0,\n  PROXIED: 1<<1,\n  TRACKING: 1<<2,\n  OPENS_IN_BROWSER: 1<<3,\n  OPENS_IN_CLIENT: 1<<4,\n};\n\nconst productImageFlags = {\n  PROXIED: 1<<0,\n  AR_WIDE: 1<<1,\n  AR_SQUARE: 1<<2,\n  AR_TALL: 1<<3,\n  TP_PROMO: 1<<4,\n  TP_LOGO: 1<<5,\n  TP_SHOWCASE: 1<<6,\n  TP_OTHER: 1<<7,\n  FT_WATERMARK: 1<<8,\n  FT_TAGS: 1<<9,\n};\n\nfunction parseProduct(product: Record<string, unknown>): Product {\n  product.until = product.until\n    ? new Date(product.until as string)\n    : null;\n  product.flags = createBitfield(product.flags as number, productFlags);\n  (product.urls as Array<Record<string, unknown>>).forEach(url => url.flags = createBitfield(url.flags as number, productUrlFlags));\n  (product.images as Array<Record<string, unknown>>).forEach(image => image.flags = createBitfield(image.flags as number, productImageFlags));\n  return product as Product;\n}\n\nfunction parseResolvedAnnouncement(announcement: Record<string, unknown>): ResolvedAnnouncement {\n  announcement.resolvedProducts = (announcement.resolvedProducts as Array<Record<string, unknown>>).map(parseProduct);\n  return announcement as ResolvedAnnouncement;\n}\n\nconst epochBegin = new Date('2025-01-01T00:00:00Z').getTime()\n\nfunction parseEpochTimestamp(timestamp: unknown): Date | null {\n  const asNumber = Number(timestamp);\n  if (isNaN(asNumber) || asNumber < 0) {\n    return null;\n  }\n  return new Date(epochBegin + asNumber * 1000);\n}\n\nexport function parseEvent(event: Record<string, unknown>): FsbEvent {\n  if (event.type as string === 'fsb:event:product_updated') {\n    event.data = parseProduct(event.data as Record<string, unknown>);\n  } else if (event.type as string === 'fsb:event:announcement_created') {\n    event.data = parseResolvedAnnouncement(event.data as Record<string, unknown>);\n  }\n  event.timestamp = parseEpochTimestamp(event.timestamp);\n  return event as FsbEvent;\n}\n"
  ],
  "mappings": ";AAEA;AAQA,IAAM,iBAA0B;AAAA,EAC9B,SAAS;AACX;AAAA;AAEO,MAAM,cAAc;AAAA,EAMd;AAAA,EACA;AAAA,EALH;AAAA,EACA,UAAkC,CAAC;AAAA,EAE3C,WAAW,CACA,OACA,SACT;AAAA,IAFS;AAAA,IACA;AAAA,IAET,KAAK,UAAU,QAAQ,WAAW,eAAe;AAAA,IACjD,KAAK,QAAQ,mBAAmB,UAAU;AAAA,IAC1C,KAAK,QAAQ,gBAAgB;AAAA,IAC7B,KAAK,QAAQ,kBAAkB;AAAA,IAC/B,KAAK,QAAQ,8BAA8B;AAAA;AAAA,EAGtC,OAAO,GAAG;AAAA,IACf,OAAO,MAAM;AAAA,MACX,QAAQ;AAAA,MACR,SAAS,KAAK;AAAA,MACd,SAAS,KAAK;AAAA,MACd,KAAK;AAAA,IACP,CAAC;AAAA;AAAA,EAGa,SAAS;AAAA,IACvB,UAAU,GAAG;AAAA,MACX,OAAO,MAAM,IAA8B,YAAY;AAAA,QACrD,SAAS,KAAK;AAAA,QACd,SAAS,KAAK;AAAA,MAChB,CAAC;AAAA;AAAA,IAEH,SAAS,CAAC,KAAa;AAAA,MACrB,OAAO,MAAM,IAA0B,YAAY,OAAO;AAAA,QACxD,SAAS,KAAK;AAAA,QACd,SAAS,KAAK;AAAA,MAChB,CAAC;AAAA;AAAA,IAEH,WAAW,GAAG;AAAA,MACZ,OAAO,MAAM,IAA+B,aAAa;AAAA,QACvD,SAAS,KAAK;AAAA,QACd,SAAS,KAAK;AAAA,MAChB,CAAC;AAAA;AAAA,IAEH,SAAS,GAAG;AAAA,MACV,OAAO,MAAM,IAA6B,WAAW;AAAA,QACnD,SAAS,KAAK;AAAA,QACd,SAAS,KAAK;AAAA,MAChB,CAAC;AAAA;AAAA,EAEL;AAEF;;ACpDO,SAAS,cAAoC,CAAC,MAAc,OAA+C;AAAA,EAChH,IAAI,QAAQ;AAAA,EAEZ,MAAM,UAAU,UAAU,GAAG;AAAA,IAC3B,WAAW,QAAQ,OAAO,KAAK,KAAK,GAAc;AAAA,MAChD,IAAI,QAAQ,MAAM,OAAO;AAAA,QACvB,MAAM;AAAA,MACR;AAAA,IACF;AAAA;AAAA,EAGF,OAAO;AAAA,IACL,KAAK,CAAC,UAAU,QAAQ,MAAM,WAAW;AAAA,IACzC,KAAK,CAAC,SAAS,MAAM,SAAS,MAAM;AAAA,IACpC,QAAQ,CAAC,SAAS,MAAM,UAAU,MAAM;AAAA,IACxC,QAAQ,CAAC,SAAS,MAAM,SAAS,MAAM;AAAA,IACvC,SAAS,MAAM;AAAA,IACf,UAAW,MAAM,CAAE,GAAG,QAAQ,CAAE,EAAE,KAAK,IAAI;AAAA,IAC3C,SAAU,MAAM,CAAE,GAAG,QAAQ,CAAE;AAAA,IAC/B,MAAM,MAAM,CAAE,GAAG,QAAQ,CAAE,EAAE;AAAA,KAC5B,OAAO,WAAW,MAAM,QAAQ;AAAA,EACnC;AAAA;;ACnCF;AAQA,IAAM,UAAU,IAAI;AAEb,SAAS,EAAuB,CAAC,OAAU,UAAuB;AAAA,EACvE,QAAQ,GAAG,OAAO,QAAQ;AAAA;AAGrB,SAAS,IAAyB,CAAC,OAAU,UAAuB;AAAA,EACzE,QAAQ,KAAK,OAAO,QAAQ;AAAA;AAGvB,SAAS,GAAwB,CAAC,OAAU,UAAuB;AAAA,EACxE,QAAQ,IAAI,OAAO,QAAQ;AAAA;AAGtB,SAAS,IAAI,CAAC,OAAiB;AAAA,EACpC,QAAQ,KAAK,MAAM,MAAM,KAAK;AAAA;;ACvBhC;AAqDO,SAAS,wBAAwB,CAAC,SAA0B;AAAA,EACjE,MAAM,MAAO,OAAO,QAAQ,cAAc,WACtC,gBAAgB;AAAA,IAChB,KAAK,OAAO,KAAK,QAAQ,WAAW,QAAQ;AAAA,IAC5C,QAAQ;AAAA,IACR,MAAM;AAAA,EACR,CAAC,IACC,QAAQ;AAAA,EAEZ,MAAM,gBAAgB,QAAQ,iBAAiB,IAAI,KAAK;AAAA,EACxD,MAAM,qBAAqB,QAAQ,sBAAsB;AAAA,EACzD,MAAM,qBAAqB,QAAQ,sBAAsB;AAAA,EAEzD,MAAM,mBAAgC,IAAI;AAAA,EAC1C,MAAM,wBAAwB,gBAAgB,IAAI,KAAK;AAAA,EAEvD,MAAM,wBAAwB,CAAC,SAAwB;AAAA,IACrD,MAAM,MAAM,IAAI;AAAA,IAChB,OAAQ,IAAI,QAAQ,IAAI,KAAK,QAAQ,IAAK;AAAA;AAAA,EAG5C,OAAO,CAAC,UAAiD;AAAA,IACvD,KAAK,MAAM,SAAS,MAAM,cAAc,MAAM,cAAc,MAAM,WAAW;AAAA,MAC3E,OAAO;AAAA,QACL,SAAS;AAAA,QACT,QAAQ;AAAA,QACR,aAAa;AAAA,QACb,YAAY;AAAA,MACd;AAAA,IACF;AAAA,IAEA,MAAM,SAAS,IAAI,KAAK,MAAM,SAAS;AAAA,IACvC,KAAK,uBAAuB,MAAM,OAAO,QAAQ,CAAC,KAAK,sBAAsB,MAAM,IAAI;AAAA,MACrF,OAAO;AAAA,QACL,SAAS;AAAA,QACT,QAAQ;AAAA,QACR,aAAa;AAAA,QACb,YAAY;AAAA,MACd;AAAA,IACF;AAAA,IAEA,KAAK,sBAAsB,iBAAiB,IAAI,MAAM,SAAS,GAAG;AAAA,MAChE,OAAO;AAAA,QACL,SAAS;AAAA,QACT,QAAQ;AAAA,QACR,aAAa;AAAA,QACb,YAAY;AAAA,MACd;AAAA,IACF;AAAA,IAEA,IAAI,oBAAoB;AAAA,MACtB,iBAAiB,IAAI,MAAM,SAAS;AAAA,MACpC,WAAW,MAAM;AAAA,QACf,iBAAiB,OAAO,MAAM,SAAS;AAAA,SACtC,qBAAqB;AAAA,IAC1B;AAAA,IAEA,OAAO,SAAS,UAAU,OAAO,MAAM,SAAS,EAAE,MAAM,GAAG;AAAA,IAC3D,IAAI,YAAY,OAAO;AAAA,MACrB,OAAO;AAAA,QACL,SAAS;AAAA,QACT,QAAQ;AAAA,QACR,aAAa;AAAA,QACb,YAAY;AAAA,MACd;AAAA,IACF;AAAA,IAEA,MAAM,UAAU,OAAO,KAAK,QAAS,QAAQ;AAAA,IAC7C,MAAM,cAAc,OAAO,KAAK,sBAAsB,MAAM,aAAa,MAAM,KAAK,SAAS,KAAK,MAAM;AAAA,IAExG,MAAM,QAAQ,OAAO,MAAM,IAAI,WAAW,WAAW,GAAG,KAAK,OAAO;AAAA,IACpE,KAAK,OAAO;AAAA,MACV,OAAO;AAAA,QACL,SAAS;AAAA,QACT,QAAQ;AAAA,QACR,aAAa;AAAA,QACb,YAAY;AAAA,MACd;AAAA,IACF;AAAA,IAEA,OAAO;AAAA,MACL,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,aAAa,MAAM,KAAK,SAAS,IAC7B,KAAK,MAAM,MAAM,KAAK,SAAS,CAAC,IAChC;AAAA,MACJ,YAAY,MAAM;AAAA,IACpB;AAAA;AAAA;;ACxIJ;;;ACAA,IAAM,eAAe;AAAA,EACnB,OAAO,KAAG;AAAA,EACV,YAAY,KAAG;AAAA,EACf,WAAW,KAAG;AAAA,EACd,YAAY,KAAG;AAAA,EACf,sBAAsB,KAAG;AAC3B;AAEA,IAAM,kBAAkB;AAAA,EACtB,UAAU,KAAG;AAAA,EACb,SAAS,KAAG;AAAA,EACZ,UAAU,KAAG;AAAA,EACb,kBAAkB,KAAG;AAAA,EACrB,iBAAiB,KAAG;AACtB;AAEA,IAAM,oBAAoB;AAAA,EACxB,SAAS,KAAG;AAAA,EACZ,SAAS,KAAG;AAAA,EACZ,WAAW,KAAG;AAAA,EACd,SAAS,KAAG;AAAA,EACZ,UAAU,KAAG;AAAA,EACb,SAAS,KAAG;AAAA,EACZ,aAAa,KAAG;AAAA,EAChB,UAAU,KAAG;AAAA,EACb,cAAc,KAAG;AAAA,EACjB,SAAS,KAAG;AACd;AAEA,SAAS,YAAY,CAAC,SAA2C;AAAA,EAC/D,QAAQ,QAAQ,QAAQ,QACpB,IAAI,KAAK,QAAQ,KAAe,IAChC;AAAA,EACJ,QAAQ,QAAQ,eAAe,QAAQ,OAAiB,YAAY;AAAA,EACnE,QAAQ,KAAwC,QAAQ,SAAO,IAAI,QAAQ,eAAe,IAAI,OAAiB,eAAe,CAAC;AAAA,EAC/H,QAAQ,OAA0C,QAAQ,WAAS,MAAM,QAAQ,eAAe,MAAM,OAAiB,iBAAiB,CAAC;AAAA,EAC1I,OAAO;AAAA;AAGT,SAAS,yBAAyB,CAAC,cAA6D;AAAA,EAC9F,aAAa,mBAAoB,aAAa,iBAAoD,IAAI,YAAY;AAAA,EAClH,OAAO;AAAA;AAGT,IAAM,aAAa,IAAI,KAAK,sBAAsB,EAAE,QAAQ;AAE5D,SAAS,mBAAmB,CAAC,WAAiC;AAAA,EAC5D,MAAM,WAAW,OAAO,SAAS;AAAA,EACjC,IAAI,MAAM,QAAQ,KAAK,WAAW,GAAG;AAAA,IACnC,OAAO;AAAA,EACT;AAAA,EACA,OAAO,IAAI,KAAK,aAAa,WAAW,IAAI;AAAA;AAGvC,SAAS,UAAU,CAAC,OAA0C;AAAA,EACnE,IAAI,MAAM,SAAmB,6BAA6B;AAAA,IACxD,MAAM,OAAO,aAAa,MAAM,IAA+B;AAAA,EACjE,EAAO,SAAI,MAAM,SAAmB,kCAAkC;AAAA,IACpE,MAAM,OAAO,0BAA0B,MAAM,IAA+B;AAAA,EAC9E;AAAA,EACA,MAAM,YAAY,oBAAoB,MAAM,SAAS;AAAA,EACrD,OAAO;AAAA;;;ADtDF,SAAS,oBAAoB,CAAC,QAA4B,SAAuD;AAAA,EACtH,MAAM,WAAW,yBAAyB;AAAA,IACxC,WAAW;AAAA,OACP,WAAW,CAAC;AAAA,EAClB,CAAC;AAAA,EAED,MAAM,YAAY,IAAI,EAAE,MAAM,MAAM,CAAC;AAAA,EAErC,OAAO,CAAC,KAAc,KAAe,SAAuB;AAAA,IAC1D,UAAU,KAAK,KAAK,CAAC,QAAQ;AAAA,MAC3B,IAAI,UAAU,4BAA4B,YAAkB;AAAA,MAC5D,IAAI,UAAU,oBAAoB,yEAAO;AAAA,MAEzC,IAAI,KAAK;AAAA,QACP,OAAO,KAAK,IAAI,OAAO,GAAG,EAAE,KAAK,4BAA4B;AAAA,MAC/D;AAAA,MAEA,KAAK,IAAI,MAAM;AAAA,QACb,OAAO,KAAK,IAAI,OAAO,GAAG,EAAE,KAAK,cAAc;AAAA,MACjD;AAAA,MAEA,KAAK,OAAO,SAAS,IAAI,IAAI,GAAG;AAAA,QAC9B,QAAQ,KAAK,4GAA4G;AAAA,QACzH,OAAO,KAAK,IAAI,OAAO,GAAG,EAAE,KAAK,8BAA8B;AAAA,MACjE;AAAA,MAEA,MAAM,SAAS,SAAS;AAAA,QACtB,MAAM,IAAI;AAAA,QACV,WAAW,OAAO,IAAI,QAAQ,aAAa;AAAA,QAC3C,WAAW,OAAO,IAAI,QAAQ,oBAAoB;AAAA,QAClD,WAAW,OAAO,IAAI,QAAQ,oBAAoB;AAAA,MACpD,CAAC;AAAA,MAED,KAAK,OAAO,SAAS;AAAA,QACnB,OAAO,KAAK,IAAI,OAAO,GAAG,EAAE,KAAK,wBAAwB,OAAO,QAAQ;AAAA,MAC1E;AAAA,MAEA,MAAM,oBAAoB,IAAI,QAAQ;AAAA,MACtC,IAAI,sBAAsB,cAAoB;AAAA,QAC5C,OAAO,KAAK,IAAI,OAAO,GAAG,EAAE,KAAK,iCAAiC;AAAA,MACpE;AAAA,MAEA,IAAI,OAAO,GAAG,EAAE,IAAI;AAAA,MAEpB,KAAK,OAAO,YAAY,SAAS,OAAO,OAAO,YAAY,IAAI,EAAE,WAAW,YAAY,GAAG;AAAA,QACzF,QAAQ,KAAK,sDAAsD;AAAA,QACnE,QAAQ,IAAI,OAAO,WAAW;AAAA,QAC9B;AAAA,MACF;AAAA,MAEA,KAAK,WAAW,OAAO,WAAW,CAAC;AAAA,KACpC;AAAA;AAAA;AAKE,SAAS,mBAAmB,CAAC,SAA8D;AAAA,EAChG,MAAM,UAAU,qBAAqB,QAAQ,WAAW,OAAO;AAAA,EAC/D,MAAM,MAAM,QAAQ;AAAA,EACpB,IAAI,QAAQ,OAAO;AAAA,IACjB,IAAI,IAAI,QAAQ,OAAO,OAAO;AAAA,EAChC,EAAO;AAAA,IACL,IAAI,IAAI,OAAO;AAAA;AAAA,EAEjB,QAAQ,SAAS,YAAY,QAAQ,cAAiD;AAAA,EACtF,MAAM,OAAO,QAAQ,QAAQ;AAAA,EAC7B,IAAI,OAAO,MAAM,MAAM,QAAQ,EAAE,KAAK,KAAK,CAAC,CAAC;AAAA,EAC7C,OAAO;AAAA;",
  "debugId": "D3387073EE6FDBD564756E2164756E21",
  "names": []
}